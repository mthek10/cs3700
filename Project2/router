#!/usr/bin/env python3
""" Skeleton Implementation of Project 2 for NEU CS3700 """

import argparse
import json
import select
import socket

##########################################################################################

# Message Fields
TYPE = "type"
SRCE = "src"
DEST = "dst"
MESG = "msg"
TABL = "table"

# Message Types
DATA = "data"
DUMP = "dump"
UPDT = "update"
RVKE = "revoke"
NRTE = "no route"

# Update Message Fields
NTWK = "network"
NMSK = "netmask"
ORIG = "origin"
LPRF = "localpref"
APTH = "ASPath"
SORG = "selfOrigin"

# internal route info
CUST = "cust"
PEER = "peer"
PROV = "prov"


##########################################################################################

class Router:
  """ Your Router """
  def __init__(self, networks):
    print("in init")
    self.asn = networks.pop(0)
    print(networks)
    self.routes = {} #forwarding table
    self.updates = {} #store announcements
    self.relations = {} #cust, peer, etc.
    self.sockets = {}
    for relationship in networks:
      network, relation = relationship.split("-")
      print(network)
      self.sockets[network] = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
      self.sockets[network].setblocking(0)
      self.sockets[network].connect(network)
      self.relations[network] = relation

  def lookup_routes(self, daddr):
    """ Lookup all valid routes for an address """
    # TODO
    outroutes = {}

    net_pre = daddr[0 : daddr.index('.')]

    for ip in self.routes.keys():
      ip_pre = ip[0 : ip.index('.')]
      if ip_pre == net_pre:
        outroutes[ip] = self.routes[ip]

    return outroutes

  def get_shortest_as_path(self, routes):
    """ select the route with the shortest AS Path """
    # Max size of route below
    size = 999;
    outroutes = {}

    for ip in routes.keys():
      if len(routes[ip][APTH]) < size:
        size = len(routes[ip][APTH])

    for ip in routes.keys():
      if len(routes[ip][APTH]) == size:
        outroutes[ip] = routes[ip]

    return outroutes

  def get_highest_preference(self, routes):
    """ select the route with highest preference """
    # routes is all possible routes to daddr
    outroutes = {}
    highest = 0

    for ip in routes.keys():
      if routes[ip][LPRF] > highest:
        highest = routes[ip][LPRF]

    for ip in routes.keys():
      if routes[ip][LPRF] == highest:
        outroutes[ip] = routes[ip]

    return outroutes

  def get_self_origin(self, routes):
    """ select self originating routes """
    # TODO
    outroutes = {}

    for ip in routes.keys():
      if routes[ip][SORG]:
        outroutes[ip] = routes[ip]

    return outroutes

  def get_origin_routes(self, routes):
    """ select origin routes:  IGP > EGP > UNK """
    # TODO
    outroutes = {}

    for ip in routes.keys():
      if routes[ip][ORIG] == "IGP":
        outroutes[ip] = routes[ip]

    if len(outroutes) == 0:
      for ip in routes.keys():
        if routes[ip][ORIG] == "EGP":
          outroutes[ip] = routes[ip]

    # If no IGP nor EGP were found return rest of routes bc UNK
    if len(outroutes) == 0:
      return routes

    return outroutes

  def filter_relationships(self, srcip, routes):
    """ Don't allow Peer->Peer, Peer->Prov, or Prov->Peer forwards """
    outroutes = []
    return outroutes

  def ip_to_bits(self, ip):
    i1 = ip.index('.')
    i2 = ip.index('.', i1 + 1)
    i3 = ip.index('.', i2 + 1)
    net_pre = ip[0: i1]
    net_pre2 = ip[i1 + 1: i2]
    net_pre3 = ip[i2 + 1: i3]
    net_pre4 = ip[i3 + 1: len(ip)]

    b1 = bin(int(net_pre))
    b2 = bin(int(net_pre2))
    b3 = bin(int(net_pre3))
    b4 = bin(int(net_pre4))

    rb1 = b1[2:len(ip)]
    rb2 = b2[2:len(ip)]
    rb3 = b3[2:len(ip)]
    rb4 = b4[2:len(ip)]

    print("Lucia's place:" + rb1 + '.' + rb2 + '.' + rb3 +'.'+ rb4)

    return rb1 + '.' + rb2 + '.' + rb3 +'.'+ rb4

  def compare_ips(self, ip1, ip2):
    incommon = 0

    for x in range(len(ip1)):
      if ip1[x] == ip2[x]:
        incommon += 1
      else:
        return incommon


  def get_route(self, srcip, daddr):
    """ Select the best route for a given address """
    # TODO fill in peer?
    peer = None
    pos_routes = self.lookup_routes(daddr)
    # Rules go here
    if pos_routes:
      # 1. Highest Preference
      pos_routes = self.get_highest_preference(pos_routes)
      # 2. Self Origin
      pos_routes = self.get_self_origin(pos_routes)
      # 3. Shortest ASPath
      pos_routes = self.get_shortest_as_path(pos_routes)
      # 4. EGP > IGP > UNK
      pos_routes = self.get_origin_routes(pos_routes)
      # 5. Lowest IP Address

      daddrbit = self.ip_to_bits(daddr)

      bitmap = {}
      highmap = {}

      highestincommon = 0

      for ip in pos_routes.keys():
        bitmap[ip] = self.ip_to_bits(ip)

      for ip in pos_routes.keys():
        bitversion = self.ip_to_bits(ip)
        compval = self.compare_ips(daddrbit, bitversion)
        highmap[ip] = compval
        if compval > highestincommon:
          highestincommon = compval

      lowest_ip = '0.0.0.0'
      for ip in pos_routes.keys():
        if highestincommon == highmap[ip]:
          lowest_ip = highmap[ip]


      # Final check: enforce peering relationships
      route = self.filter_relationships(srcip, pos_routes)
      peer = route
    return self.sockets[peer] if peer else None

  def forward(self, srcip, packet):
    """ Forward a data packet """
    print("in forward")

    # get route to send packet
    best_route = self.get_route(srcip, packet['dst'])

    sock = self.sockets[best_route]


    jsonpack = json.dumps(packet)
    print("sending json")
    sock.sendall(jsonpack.encode())
    # TODO fix src and dest
    return False

  def coalesce(self):
    """ coalesce any routes that are right next to each other """
    # TODO (this is the most difficult task, save until last)   
    return False

  def update(self, srcip, packet):
    """ handle update packets """
    print("in update")

    # TODO save copy of announcement
    self.updates;

    # add entry to forwarding table

    # decide if send copies of announcement to neighboring routers

    self.updates[srcip] = packet
    msg = packet[MESG]
    self.routes[srcip] = msg
    for ip in self.sockets.keys():
      if not(ip == srcip):
        print("called forward")
        self.forward(ip,packet)


    # TODO
    return False

  def revoke(self, packet):
    """ handle revoke packets """
    # TODO
    return True

  def dump(self, packet):
    """ handles dump table requests """
    # TODO
    packet['type'] = "table"
    src = packet['src']
    packet['src'] = packet['dst']
    packet['dst'] = src

    print("creating table string")
    # TODO fill out table string with routing table
    table_string = ""
    # TODO asking for int indexes instead of string for route?
    for ip in self.routes.keys():
      print("route: " + route)
      # TODO have to fill ip address of peer
      entry = "\"network\" : \"<" + self.routes[ip]['network'] + ">\", \"netmask\" : \"<" + self.routes[ip]['netmask'] + ">\", \"peer\" : \"<" + "PEER"  + ">\""
      table_string += entry
    packet['msg'] = "\[\n" + table_string + "\n\]"
    msg = json.dumps(packet)
    print("dumping msg: ")
    print(msg)

    return True

  def handle_packet(self, srcip, packet):
    """ dispatches a packet """
    # TODO
    print("REACHED HANDLE PACKET")
    type = packet['type']
    print (type)
    if type == 'update':
      self.update(srcip, packet)
      print("sending to update")
    elif type == 'dump':
      self.dump(packet)
      print("sending to dump")
    elif type == 'data':
      # check if a route is in forwarding table
      # if so forward
      self.forward(srcip,packet)
      # TODO if no route found send to no route (Send error)


      print("sending to forward")
    elif type == 'revoke':
      self.revoke(packet)
      print("sending to revoke")

    return False

  def send_error(self, conn, msg):
    """ Send a no_route error message """
    # dst ip becomes src ip to return the message

    # src ip becomes this ip

    # type becomes "no route"

    # msg is empty

    # send from port incoming...current dst ip?

    # TODO

    return

  def run(self):
    """ main loop for the router """
    while True:
      socks = select.select(self.sockets.values(), [], [], 0.1)[0]
      for conn in socks:
        try:
          k = conn.recv(65535)
        except:
          # either died on a connection reset, or was SIGTERM's by parent
          return
        if k:
          for sock in self.sockets:
            if self.sockets[sock] == conn:
              srcip = sock
          msg = json.loads(k)
          # TODO commented out below code because handled by handle packet
          #self.update(srcip, msg)
          #print(msg[TYPE])
          #print(json.dumps(msg, sort_keys=True, indent=4))
          if not self.handle_packet(srcip, msg):
            self.send_error(conn, msg)
        else:
          return

if __name__ == "__main__":
  PARSER = argparse.ArgumentParser(description='route packets')
  PARSER.add_argument('networks', type=str, nargs='+', help="networks")
  args = PARSER.parse_args()
  networks = args.networks
  #print(networks)
  router = Router(args.networks).run()   #custruct router object and call run method
